
#Область ОбработчикиСобытийФормы 

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)  
	ТекстСправки = "К сожалению, при миграции на Postgres на этапе создания индексов если в таблице есть дубли по ключевым полям, то индекс не создается. 
	|В отчете статус у этих индексов будет «Удален».  
	|Это можно сделать в консоли PG admin или выполнить скрипт ALTER TABLE IF EXISTS public._Имя_Таблицы  CLUSTER ON _Имя_индекса; 
	|Как раз для этого и созданы скрипты для создания индексов и для удаления этих задублированных строк по ключевым полям. 
	|Вначале делам для КЛАСТЕРНОГО индекса, потом, если есть для остальных индексов: 
	|1. Пробуем вначале создать индекс по соответствующему скрипту из отчета. 
	|2. Если индекс не создается по ошибке: «ERROR: Ключ (_fld71rref, _fld72rref)=(\x855e005056a0012711efee98a679cb46, \x855e005056a0012711efee91e986438a, \x855e005056a0012711efee91e9cf742e) дублируется.создать уникальный индекс ""_inforg70_1"" не удалось», 
	|то следует использовать скрипты по удалению задублированных строк. Крипт нужно использовать осторожно.
	|3. Переходим к п.1
	|Кроме того 1С не предоставляет информацию по тому кластерный это индекс или нет. 
	|Поэтому нужно вручную определить признак кластерный это индекс и выставить его.";	
	ВидимостьПриСменеРежима(ЭтаФорма);
	ТекстЗапроса();
КонецПроцедуры

&НаСервере
Процедура ПриЗагрузкеДанныхИзНастроекНаСервере(Настройки)
	ВидимостьПриСменеРежима(ЭтаФорма);
	ТекстЗапроса();
КонецПроцедуры

&НаСервере
Процедура ОбработкаПроверкиЗаполненияНаСервере(Отказ, ПроверяемыеРеквизиты)
	// Исключаем из проверки реквизиты, заполнение которых стало необязательным:
	МассивНепроверяемыхРеквизитов = Новый Массив();
	Если Режим = 0 Тогда
		МассивНепроверяемыхРеквизитов.Добавить("ПутьКФайлуSQL");
	Иначе
		МассивНепроверяемыхРеквизитов.Добавить("ИмяСервераSQL");
		МассивНепроверяемыхРеквизитов.Добавить("ПользовательSQL");
		МассивНепроверяемыхРеквизитов.Добавить("ПарольSQL");
		МассивНепроверяемыхРеквизитов.Добавить("БазаДанныхSQL");
	КонецЕсли;
	// Удаляем из проверяемых реквизитов все, по которым автоматическая проверка не нужна:
	УдалитьНепроверяемыеРеквизитыИзМассива(ПроверяемыеРеквизиты, МассивНепроверяемыхРеквизитов);
	
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовШапкиФормы 

&НаКлиенте
Процедура ПутьКФайлуSQLНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	ДиалогВыбораФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	ДиалогВыбораФайла.МножественныйВыбор = Ложь;
	ДиалогВыбораФайла.ПолноеИмяФайла = ПутьКФайлуSQL;
	ДиалогВыбораФайла.Расширение = "csv";
	ДиалогВыбораФайла.Фильтр = "CSV (разделители - запятые)(*.csv)|*.csv";
	ДиалогВыбораФайла.Показать(Новый ОписаниеОповещения("ВыборФайлаОкончание", ЭтотОбъект));
КонецПроцедуры

&НаКлиенте
Процедура ВыборФайлаОкончание(ВыбранныеФайлы, ДополнительныеПараметры) Экспорт
	Если ВыбранныеФайлы <> Неопределено Тогда
		ПутьКФайлуSQL = ВыбранныеФайлы[0];
	КонецЕсли;	
КонецПроцедуры

&НаКлиенте
Процедура РежимПриИзменении(Элемент)
	ВидимостьПриСменеРежима(ЭтаФорма);
	ТекстЗапроса();
КонецПроцедуры

#КонецОбласти

#Область ОбработчикиСобытийЭлементовТаблицы 

#КонецОбласти

#Область ОбработчикиКомандФормы 

&НаКлиенте
Процедура Сформировать(Команда)
	Если ЭтаФорма.ПроверитьЗаполнение() Тогда 
		ДеревоSQL.ПолучитьЭлементы().Очистить();
		Если Режим = 0 Тогда
			
			ЗаполнитьДеревоИзБазы();
			СформироватьНаСервере();
			
		Иначе
			
			Файл = Новый Файл(ПутьКФайлуSQL);
			Файл.НачатьПроверкуСуществования(Новый ОписаниеОповещения("ПроверкаСуществованияОкончание", ЭтотОбъект));
			
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры 

&НаКлиенте
Процедура ПроверкаСуществованияОкончание(Существует, ДополнительныеПараметры) Экспорт
	Если Существует Тогда
		Файл = Новый Файл(ПутьКФайлуSQL);
		Файл.НачатьПроверкуЭтоФайл(Новый ОписаниеОповещения("ПроверкаЭтоФайлОкончание", ЭтотОбъект));
	Иначе
		Сообщить("Файл " + ПутьКФайлуSQL + " не существует!");
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПроверкаЭтоФайлОкончание(ЭтоФайл, ДополнительныеПараметры) Экспорт
	Если ЭтоФайл Тогда
		ДвоичныеДанные = Новый ДвоичныеДанные(ПутьКФайлуSQL);
		Адрес = ПоместитьВоВременноеХранилище(ДвоичныеДанные, УникальныйИдентификатор);
		СформироватьНаСервере();
		//РазвернутьДерево();
	Иначе
		Сообщить("Файл " + ПутьКФайлуSQL + " не существует!");
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции 
 
&НаКлиентеНаСервереБезКонтекста
Процедура ВидимостьПриСменеРежима(Форма)
	Если Форма.Режим = 0 Тогда
		Форма.Элементы.Группа_0.Видимость = Истина;	
		Форма.Элементы.Группа_1.Видимость = Ложь;	
	Иначе	
		Форма.Элементы.Группа_0.Видимость = Ложь;	
		Форма.Элементы.Группа_1.Видимость = Истина;	
	КонецЕсли;	
КонецПроцедуры

// Процедура удаляет из массива МассивРеквизитов элементы, соответствующие именам 
// реквизитов объекта из массива МассивНепроверяемыхРеквизитов.
// Для использования в обработчиках события ОбработкаПроверкиЗаполнения.
//
// Параметры:
//  МассивРеквизитов              - Массив - коллекция имен реквизитов объекта.
//  МассивНепроверяемыхРеквизитов - Массив - коллекция имен реквизитов объекта, не требующих проверки.
//
Процедура УдалитьНепроверяемыеРеквизитыИзМассива(МассивРеквизитов, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивНепроверяемыхРеквизитов Цикл
	
		ПорядковыйНомер = МассивРеквизитов.Найти(ЭлементМассива);
		Если ПорядковыйНомер <> Неопределено Тогда
			МассивРеквизитов.Удалить(ПорядковыйНомер);
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Процедура СформироватьНаСервере()
	
	ТаблицаРасходения = ТаблицаРасходения();
	//Получаем схему из макета
	СхемаКомпоновкиДанных = РеквизитФормыВЗначение("Отчет").ПолучитьМакет("ОсновнаяСхемаКомпоновкиДанных");
	// Связь между таблицей значений и именами в СКД 
	ВнешниеНаборыДанных = Новый Структура;
	ВнешниеНаборыДанных.Вставить("Таблица", ТаблицаРасходения);
	
	Настройки = Отчет.КомпоновщикНастроек.ПолучитьНастройки();
	
	// Помещаем в переменную данные о расшифровке данных
	ДанныеРасшифровки = Новый ДанныеРасшифровкиКомпоновкиДанных;

	// Формируем макет, с помощью компоновщика макета
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;

	// Передаем в макет компоновки схему, настройки и данные расшифровки
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, Настройки, ДанныеРасшифровки);

	// Выполним компоновку с помощью процессора компоновки
	ПроцессорКомпоновкиДанных = Новый ПроцессорКомпоновкиДанных;
	ПроцессорКомпоновкиДанных.Инициализировать(МакетКомпоновки, ВнешниеНаборыДанных, ДанныеРасшифровки);

	// Очищаем поле табличного документа
	Результат.Очистить();
	
	// Выводим результат в табличный документ
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	ПроцессорВывода.УстановитьДокумент(Результат);
	
	ПроцессорВывода.Вывести(ПроцессорКомпоновкиДанных);
	
КонецПроцедуры

&НаСервере
Функция ТаблицаРасходения()
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("ИмяТаблицы1С", Новый ОписаниеТипов("Строка", ,
											 Новый КвалификаторыСтроки(200, ДопустимаяДлина.Переменная))); 
	Таблица.Колонки.Добавить("ИмяТаблицыSQL", Новый ОписаниеТипов("Строка", ,
											 Новый КвалификаторыСтроки(100, ДопустимаяДлина.Переменная))); 
	Таблица.Колонки.Добавить("ИмяИндекса", Новый ОписаниеТипов("Строка", ,
											 Новый КвалификаторыСтроки(100, ДопустимаяДлина.Переменная))); 
	Таблица.Колонки.Добавить("ИмяПоля", Новый ОписаниеТипов("Строка", ,
											 Новый КвалификаторыСтроки(100, ДопустимаяДлина.Переменная))); 
	Таблица.Колонки.Добавить("Скрипт", Новый ОписаниеТипов("Строка", ,
									   Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Таблица.Колонки.Добавить("ВключенныеКолонки", Новый ОписаниеТипов("Строка", ,
									   Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Таблица.Колонки.Добавить("СкриптУдаленияДублей", Новый ОписаниеТипов("Строка", ,
									   Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная)));
	Таблица.Колонки.Добавить("Статус", Новый ОписаниеТипов("Строка", ,
									   Новый КвалификаторыСтроки(20, ДопустимаяДлина.Переменная)));
	Таблица.Колонки.Добавить("ПорядокПоля", Новый ОписаниеТипов("Число",
											Новый КвалификаторыЧисла(5, 0, ДопустимыйЗнак.Неотрицательный)));
							 
	Если Режим = 1 Или Режим = 2 Тогда
		ПолучитьДеревоИзФайла();	
	КонецЕсли;
	
	Дерево1С = ПолучитьДерево1С();

	ПроверенныеТаблицы = Новый Массив;
	ШаблонКластер = "
	|ALTER TABLE IF EXISTS public.%2
    |	CLUSTER ON %1";
	ШаблонВключенныхКолонок = "	INCLUDE(%1)";
	Для каждого СтрТаблица_SQL Из ДеревоSQL.ПолучитьЭлементы() Цикл
		ДанныеСтроки = Неопределено;
		СтрТаблица_1С = Дерево1С.Строки.Найти(СтрТаблица_SQL.ИмяТаблицыSQL, "ИмяТаблицыSQL", Ложь);
		ПроверенныеИндексы1С = Новый Массив;
		ПроверенныеТаблицы.Добавить(СтрТаблица_SQL.ИмяТаблицыSQL);
		Для каждого СтрИндекс_SQL Из СтрТаблица_SQL.ПолучитьЭлементы() Цикл
			СовпадениеИндекса = Ложь;
			Если СтрТаблица_1С = Неопределено Тогда
				СтрИндекса_1С = Неопределено;	
			ИначеЕсли СтрТаблица_1С.Строки.Найти(СтрИндекс_SQL.Поля, "Поля") = Неопределено Тогда
				СтрИндекса_1С = СтрТаблица_1С.Строки.Найти(СтрИндекс_SQL.ИмяИндексаДляПоиска, "ИмяИндексаДляПоиска");
			ИначеЕсли Не ЗначениеЗаполнено(СтрИндекс_SQL.ВключенныеКолонки) Тогда
				СовпадениеИндекса = Истина;
			КонецЕсли;
			Если СовпадениеИндекса Тогда
				ПроверенныеИндексы1С.Добавить(СтрИндекс_SQL.Поля);
			Иначе
				ДанныеСтроки = Новый Структура("ИмяТаблицыSQL,ИмяИндекса,Статус,Скрипт,СкриптУдаленияДублей,ВключенныеКолонки"); 
				ДанныеСтроки.Вставить("ИмяТаблицы1С", "");
				ДанныеСтроки.ИмяТаблицыSQL 		= СтрТаблица_SQL.ИмяТаблицыSQL;
				ДанныеСтроки.ИмяИндекса 		= СтрИндекс_SQL.ИмяИндекса;
				ДанныеСтроки.ВключенныеКолонки 	= СтрИндекс_SQL.ВключенныеКолонки;
				Если СтрТаблица_1С <> Неопределено Тогда
					ДанныеСтроки.ИмяТаблицы1С = СтрТаблица_1С.ИмяТаблицы1С;
				КонецЕсли;
				
				Если Режим <> 2 Тогда
					Поля = СтрЗаменить(СтрИндекс_SQL.Поля, ",", " ASC NULLS LAST, ") + " ASC NULLS LAST" ;
					Если СтрИндекса_1С = Неопределено Тогда
						Параметр4 = "--";
					Иначе
						Параметр4 = "";
					КонецЕсли;
					Если СтрИндекс_SQL.ТипИндекса = "Clustered index" Тогда
						Параметр5 = СтрШаблон(ШаблонКластер,ДанныеСтроки.ИмяИндекса, ДанныеСтроки.ИмяТаблицыSQL);
					Иначе	
						Параметр5 = "";
					КонецЕсли;
					Если ЗначениеЗаполнено(СтрИндекс_SQL.ВключенныеКолонки) Тогда
						Параметр6 = СтрШаблон(ШаблонВключенныхКолонок,СтрЗаменить(СтрИндекс_SQL.ВключенныеКолонки, ",", ", "));
					Иначе	
						Параметр6 = "";
					КонецЕсли;
					ДанныеСтроки.Скрипт = СтрШаблон(ШаблонСкрипта(), ДанныеСтроки.ИмяИндекса, ДанныеСтроки.ИмяТаблицыSQL, Поля, Параметр4, Параметр5, Параметр6);
					ДанныеСтроки.СкриптУдаленияДублей = "";
				Иначе
					ДанныеСтроки.Скрипт = "";
					ДанныеСтроки.СкриптУдаленияДублей = "";
				КонецЕсли;
				ДанныеСтроки.Статус = "Добавлен";
				
				Сч = 1;
				Для каждого Поле Из СтрРазделить(СтрИндекс_SQL.Поля, ",") Цикл
					НоваяСтрока = Таблица.Добавить(); 
					ЗаполнитьЗначенияСвойств(НоваяСтрока, ДанныеСтроки);
					НоваяСтрока.ИмяПоля = Поле;
					НоваяСтрока.ПорядокПоля = Сч;
					Сч = Сч + 1;
				КонецЦикла;
				
				Если СтрИндекса_1С <> Неопределено Тогда
					ДанныеСтроки.Скрипт = "";
					ДанныеСтроки.СкриптУдаленияДублей = "";
					ДанныеСтроки.ВключенныеКолонки = "";
					ДанныеСтроки.Статус = "Удален";  
					ПроверенныеИндексы1С.Добавить(СтрИндекса_1С.Поля);
					Для Сч = 1 По СтрИндекса_1С.Строки.Количество() Цикл
						НоваяСтрока = Таблица.Добавить(); 
						ЗаполнитьЗначенияСвойств(НоваяСтрока, ДанныеСтроки);
						НоваяСтрока.ИмяПоля = СтрИндекса_1С.Строки[Сч - 1].ИмяПоля;	
						НоваяСтрока.ПорядокПоля = Сч;
					КонецЦикла;
				КонецЕсли;
				
			КонецЕсли;	
		КонецЦикла;		
		
		// Проход по индексам 1С, которые отсутстсвуют в СКЛ по этой же таблице
		Если СтрТаблица_1С <> Неопределено Тогда
			Для Каждого СтрИндекса_1С Из СтрТаблица_1С.Строки Цикл
				Если ПроверенныеИндексы1С.Найти(СтрИндекса_1С.Поля) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
					
				Если ДанныеСтроки = Неопределено Тогда
					ДанныеСтроки = Новый Структура; 
					ДанныеСтроки.Вставить("ИмяТаблицыSQL", СтрТаблица_SQL.ИмяТаблицыSQL);
					ДанныеСтроки.Вставить("ИмяТаблицы1С", СтрТаблица_1С.ИмяТаблицы1С);
				Иначе
					ДанныеСтроки.Вставить("Скрипт", "");
					ДанныеСтроки.Вставить("СкриптУдаленияДублей", "");
					ДанныеСтроки.Вставить("ВключенныеКолонки", "");
				КонецЕсли;

				ДополнитьНедостающимиИндексами(Таблица, ДанныеСтроки, СтрТаблица_1С, СтрИндекса_1С);
	
			КонецЦикла;	
		КонецЕсли;
	КонецЦикла;
	
	// Проход по таблицам 1с, которых не было в SQL. Теоретически такого не может быть
	Для Каждого СтрТаблица_1С Из Дерево1С.Строки Цикл
		ДанныеСтроки = Неопределено;
		Если ПроверенныеТаблицы.Найти(СтрТаблица_1С.ИмяТаблицыSQL) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ДанныеСтроки = Неопределено Тогда
			ДанныеСтроки = Новый Структура;
			ДанныеСтроки.Вставить("ИмяТаблицыSQL", СтрТаблица_1С.ИмяТаблицыSQL);
			ДанныеСтроки.Вставить("ИмяТаблицы1С", СтрТаблица_1С.ИмяТаблицы1С);
		КонецЕсли;
					
		Для Каждого СтрИндекса_1С Из СтрТаблица_1С.Строки Цикл
			ДополнитьНедостающимиИндексами(Таблица, ДанныеСтроки, СтрТаблица_1С, СтрИндекса_1С);
		КонецЦикла;
			
	КонецЦикла;
	
	Возврат Таблица;
	
КонецФункции

&НаСервере
Функция ШаблонСкрипта()
	ШаблонСкрипта = "-- Index: %1
	|%4 DROP INDEX IF EXISTS public.%1;
    |
	|CREATE UNIQUE INDEX IF NOT EXISTS %1
    |	ON public.%2 USING btree
    |	(%3)
	|%6	TABLESPACE pg_default;
	|%5";
	Возврат ШаблонСкрипта;
КонецФункции

&НаСервере
Функция ШаблонСкриптаУдаленияДублей()
	// %1 - Имя таблицы
	// %2 - Поля-ключи через запятую с псевдонимом таблицы t1
	// %3 - Все поля таблицы через запятую без псевдонима таблицы 
	// %4 - Все поля таблицы через запятую с псевдонимом таблицы t1
	// %5 - соединения полей-ключей таблицы t1 и t2
	ШаблонСкриптаУдаленияДублей = "
	|DO $$
	|DECLARE
	|	TotalNumStart bigint; -- Общее количество записей в таблице %1 до преобразования
	|	NumUnique  bigint; -- Количество уникальных ключей из задублированных в таблице %1
	|	TotalNumDupl bigint; -- Общее количество задублированных записей
	|	TotalNumEnd bigint; -- Общее количество записей в таблице %1 После преобразования
	|	Res bigint; -- Результат замены TotalNumStart + TotalNumDupl - TotalNumDupl - TotalNumEnd = 0 
	|	TotalNumExpec bigint; -- Ожидаемое колиичество записей в таблице %1 после преобразования TotalNumStart - TotalNumDupl + TotalNumDupl 
	|BEGIN
	|	
	|	-- Создание и заполнение временной таблицы, куда поместим уникальные записи из задвоенных
	|	DROP TABLE IF EXISTS pg_temp.tt1
	|	; 
	|	CREATE TEMP TABLE pg_temp.tt1 (LIKE public.%1)
	|	;
	|	INSERT INTO pg_temp.tt1(%3)
	|	select DISTINCT ON (%2)
	|		t1.*
	|	from public.%1 t1
	|	join
	|		(select 
	|			%2
	|		from public.%1 t1
	|		group by 
	|			%2
	|		HAVING count(*) > 1
	|		) t2
	|	on %5
	|	;
	|	
	|	-- Количество уникальных ключей из задублированных
	|	select 
	|		count(*) INTO NumUnique 
	|	from pg_temp.tt1
	|	;
	|	
	|	RAISE NOTICE 'Удаление дублей по ключевым полям индекса %6 в таблице %1:'; 
	|	-- Если есть дубли, то удаляем их	
	|	if NumUnique = 0 then
	|	
	|		RAISE NOTICE 'В таблице отсутствуют дубли по ключевым полям индекса'; 
	|	
	|	else	
	|	
	|		-- Общее начальное количество записей в таблице %1
	|		select 
	|			count(*) INTO TotalNumStart 
	|		from %1
	|		;
	|	
	|		-- Общее количество задублированных записей
	|		select 
	|			count(*) INTO TotalNumDupl
	|		from public.%1 t1
	|		join pg_temp.tt1 t2
	|		on %5
	|		;
	|	
	|		-- Удаление задублированных и добавление сгруппированных записей
	|		delete from public.%1 t1
	|		using pg_temp.tt1 t2
	|		where 
	|			%5
	|		;
	|		INSERT INTO %1(%3)
	|		select 
	|			%4
	|		from pg_temp.tt1 t1
	|		; 
	|		
	|		-- Общее конечное количество записей в таблице %1
	|		select 
	|			count(*) INTO TotalNumEnd 
	|		from %1
	|		;
	|		
	|		-- Вывод результат
	|		select	
	|			TotalNumStart + NumUnique - TotalNumDupl - TotalNumEnd INTO Res
	|		;
	|		select	
	|			TotalNumStart + NumUnique - TotalNumDupl INTO TotalNumExpec	
	|		;
	|	
	|		RAISE NOTICE 'Общее количество записей в таблице до преобразования: ПРОЦЕНТ', TotalNumStart; 
	|		RAISE NOTICE 'Количество уникальных ключей из задублированных: ПРОЦЕНТ', NumUnique; 
	|		RAISE NOTICE 'Общее количество задублированных записей: ПРОЦЕНТ', TotalNumDupl; 
	|		if Res = 0 then	
	|			RAISE NOTICE 'Общее количество записей в таблице После преобразования: ПРОЦЕНТ', TotalNumEnd; 
	|			RAISE NOTICE 'Удаление дублей по ключевым записям успешно выполнено'; 
	|		else
	|			RAISE NOTICE 'Неудача при удалении дублей по ключевым записям. Ожидалось, что в таблице %1 после преобразований останется ПРОЦЕНТ записей, а по факту в ней осталось ПРОЦЕНТ записей', TotalNumExpec, TotalNumEnd; 
	|			ROLLBACK;
	|		end if;	
	|	end if;	
	|end $$;
	|";
	Возврат ШаблонСкриптаУдаленияДублей;
КонецФункции

&НаСервере
Функция ШаблонСкриптаMSSQL()
	ШаблонСкрипта = "-- Index: %1
	|%4 DROP INDEX IF EXISTS %1;
    |
	|	
	|CREATE UNIQUE CLUSTERED INDEX [%1] ON [dbo].[%2]
	|(
	|	%3
	|)WITH (PAD_INDEX = OFF, STATISTICS_NORECOMPUTE = OFF, SORT_IN_TEMPDB = OFF, IGNORE_DUP_KEY = OFF, DROP_EXISTING = OFF, ONLINE = OFF, ALLOW_ROW_LOCKS = ON, ALLOW_PAGE_LOCKS = OFF) ON [PRIMARY]
	|GO";
	Возврат ШаблонСкрипта;
КонецФункции

&НаСервере
Процедура ДополнитьНедостающимиИндексами(Таблица, ДанныеСтроки, СтрТаблица_1С, СтрИндекса_1С)
	
	ДанныеСтроки.Вставить("ИмяИндекса", СтрИндекса_1С.ИмяИндекса);
	ДанныеСтроки.Вставить("Статус", "Удален");
	
	Если Режим = 2 Тогда
		
		// Параметры в шаблоне
		// %1 - Имя таблицы
		// %2 - Поля-ключи индекса через запятую с псевдонимом таблицы t1
		// %3 - Все поля таблицы через запятую без псевдонима таблицы 
		// %4 - Все поля таблицы через запятую с псевдонимом таблицы t1
		// %5 - соединения полей-ключей таблицы t1 и t2
		Пар2 = "";
		Пар3 = "";
		Пар4 = "";
		Пар5 = "";
		
		Для каждого СтрокаПоля Из СтрТаблица_1С.ПоляТаблица Цикл
			Пар3 = СтрШаблон("%1%2%3", Пар3, ?(ПустаяСтрока(Пар3), "", ","), НРег(СтрокаПоля.ИмяПоляХранения));	
			Пар4 = СтрШаблон("%1%2t1.%3", Пар4, ?(ПустаяСтрока(Пар4), "", ","), НРег(СтрокаПоля.ИмяПоляХранения));	
		КонецЦикла;
		
		Для каждого СтрокаПоля Из СтрИндекса_1С.ПоляТаблица Цикл
			Пар2 = СтрШаблон("%1%2t1.%3", Пар2, ?(ПустаяСтрока(Пар2), "", ","), НРег(СтрокаПоля.ИмяПоляХранения));	
			Пар5 = СтрШаблон("%1%2t1.%3 = t2.%3", Пар5, ?(ПустаяСтрока(Пар5), "", " and "), НРег(СтрокаПоля.ИмяПоляХранения));	
		КонецЦикла;
		
		Поля = СтрЗаменить(СтрИндекса_1С.Поля, ",", " ASC NULLS LAST, ") + " ASC NULLS LAST" ;
		Параметр4 = "--";
		Параметр5 = "";
		Параметр6 = "";
		ДанныеСтроки.Вставить("Скрипт", СтрШаблон(ШаблонСкрипта(), ДанныеСтроки.ИмяИндекса, ДанныеСтроки.ИмяТаблицыSQL, Поля, Параметр4, Параметр5, Параметр6));
		ШаблонСкриптаУдаленияДублей = ШаблонСкриптаУдаленияДублей();
		ШаблонСкриптаУдаленияДублей = СтрШаблон(ШаблонСкриптаУдаленияДублей, ДанныеСтроки.ИмяТаблицыSQL, Пар2, Пар3, Пар4, Пар5, ДанныеСтроки.ИмяИндекса);
		ШаблонСкриптаУдаленияДублей = СтрЗаменить(ШаблонСкриптаУдаленияДублей, "ПРОЦЕНТ", "%");
		ДанныеСтроки.Вставить("СкриптУдаленияДублей", ШаблонСкриптаУдаленияДублей);

	Иначе
		Поля = СтрЗаменить(СтрИндекса_1С.Поля, ",", " ASC, ") + " ASC" ;
		Параметр4 = "--";
		ДанныеСтроки.Вставить("Скрипт", СтрШаблон(ШаблонСкриптаMSSQL(), ДанныеСтроки.ИмяИндекса, ДанныеСтроки.ИмяТаблицыSQL, Поля, Параметр4)); 
		// Пока не буду делять удаление дублей для MSSQL
		ДанныеСтроки.Вставить("СкриптУдаленияДублей", "");
		
	КонецЕсли;
	
	
	Сч = 1;
	Для каждого СтрокаПоля_1С Из СтрИндекса_1С.Строки Цикл
		НоваяСтрока = Таблица.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ДанныеСтроки);
		НоваяСтрока.ИмяПоля = СтрокаПоля_1С.ИмяПоля;	
		НоваяСтрока.ПорядокПоля = Сч;
		Сч = Сч + 1;
	КонецЦикла;	
КонецПроцедуры

&НаСервере
Процедура ПолучитьДеревоИзФайла()
	
	ИмяВремФайла = ПолучитьИмяВременногоФайла("csv");
	ПолучитьИзВременногоХранилища(Адрес).Записать(ИмяВремФайла);
	ЧтениеТекста = Новый ЧтениеТекста(ИмяВремФайла);
	ТекТаблица = "";
	СтрИндекс = Неопределено;
	Пока Истина Цикл
		Строка = НРег(ЧтениеТекста.ПрочитатьСтроку());
		Если Строка = Неопределено Или ПустаяСтрока(Строка) Тогда
			Прервать;	
		КонецЕсли;
		Строка = СтрЗаменить(Строка, """,""", ";");
		Строка = СтрЗаменить(Строка, ",""", ";");
		Строка = СтрЗаменить(Строка, """,", ";");
		Строка = СтрЗаменить(Строка, """", "");
		Массив = СтрРазделить(Строка, ";", Истина);
		Если Массив[0] = "table_name" Тогда
			Продолжить;	
		КонецЕсли;
		Если Массив[0] <> ТекТаблица Тогда
			СтрТаблица = ДеревоSQL.ПолучитьЭлементы().Добавить();
			СтрТаблица.ИмяТаблицыSQL = Массив[0];
			ТекТаблица = Массив[0];
		КонецЕсли;
		СтрИндекс = СтрТаблица.ПолучитьЭлементы().Добавить();
		СтрИндекс.ИдИндекса = Формат(Массив[1], "ЧГ=0");
		СтрИндекс.ИмяИндекса = Массив[2];
		СтрИндекс.ТипИндекса = Массив[5];
		СтрИндекс.Уникальный = Массив[6] = "Unique";
		СтрИндекс.ИмяИндексаДляПоиска = СтрИндекс.ИмяИндекса;
		СтрИндекс.Поля = Массив[3];
		СтрИндекс.ВключенныеКолонки = Массив[4];
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Функция ПолучитьДерево1С()
	
	ТЗБД=ПолучитьСтруктуруХраненияБазыДанных(,Истина);
	Дерево1С = Новый ДеревоЗначений;
	Дерево1С.Колонки.Добавить("ИмяТаблицы1С");
	Дерево1С.Колонки.Добавить("ИмяТаблицыSQL");
	Дерево1С.Колонки.Добавить("ИмяИндекса");
	Дерево1С.Колонки.Добавить("ИмяИндексаДляПоиска");
	Дерево1С.Колонки.Добавить("ИдИндекса");
	Дерево1С.Колонки.Добавить("ИмяПоля");
	Дерево1С.Колонки.Добавить("ИдПоля");
	Дерево1С.Колонки.Добавить("Поля");
	Дерево1С.Колонки.Добавить("ПоляТаблица");
	Для каждого СтрокаТаблицы Из ТЗБД Цикл
		Если СтрокаТаблицы.Индексы.Количество() = 0 Тогда
			Продолжить;	
		КонецЕсли;
		СтрТаблица = Дерево1С.Строки.Добавить();
		СтрТаблица.ИмяТаблицы1С = ?(ЗначениеЗаполнено(СтрокаТаблицы.Метаданные), СтрокаТаблицы.Метаданные, СтрокаТаблицы.Назначение);
		СтрТаблица.ИмяТаблицыSQL = НРег(СтрокаТаблицы.ИмяТаблицыХранения); 
		СтрТаблица.ПоляТаблица = СтрокаТаблицы.Поля.Скопировать();
		ИдИндекса = 1;
		Для каждого СтрокаИндекса Из СтрокаТаблицы.Индексы Цикл
			СтрИндекс = СтрТаблица.Строки.Добавить();
			СтрИндекс.ИдИндекса = ИдИндекса;
			СтрИндекс.ИмяИндекса = НРег(СтрокаИндекса.ИмяИндексаХранения);
			СтрИндекс.ИмяИндексаДляПоиска = НРег(СтрокаИндекса.ИмяИндексаХранения);
			ИдПоля = 1;
			Поля = "";
			Для каждого СтрокаПоля Из СтрокаИндекса.Поля Цикл
				НоваяСтрока = СтрИндекс.Строки.Добавить();
				НоваяСтрока.ИмяПоля = СтрокаПоля.ИмяПоляХранения;
				НоваяСтрока.ИдПоля = ИдПоля;
				Поля = Поля + ?(ПустаяСтрока(Поля), "", ",") + НРег(НоваяСтрока.ИмяПоля);
				ИдПоля = ИдПоля + 1;
			КонецЦикла;	
			СтрИндекс.Поля = НРег(Поля);	
			СтрИндекс.ПоляТаблица = СтрокаИндекса.Поля.Скопировать();
			ИдИндекса = ИдИндекса + 1;
		КонецЦикла;	
	КонецЦикла;

	Возврат Дерево1С;
	
КонецФункции

&НаКлиенте
Процедура ЗаполнитьДеревоИзБазы()
	
	/////////////////////////////////////////
    //Подключение к SQL-серверу
    Попытка
        Соединение  = Новый COMОбъект("ADODB.Connection");
        Команда     = Новый COMОбъект("ADODB.Command");
        Выборка     = Новый COMОбъект("ADODB.RecordSet");
        Соединение.ConnectionString =
            "driver={SQL Server};" +
            "server="+ИмяСервераSQL+";"+
            "uid="+ПользовательSQL+";"+
            "pwd="+ПарольSQL+";"+
            "database="+БазаДанныхSQL+";";
        Соединение.ConnectionTimeout = 30;
        Соединение.CommandTimeout = 600;
        Соединение.Open();
        Команда.ActiveConnection   = Соединение;
    Исключение
        Сообщить(ОписаниеОшибки());
        Возврат;
    КонецПопытки;

    /////////////////////////////////////////
    //Читаем записи
    Попытка
        Команда.CommandText = ТекстЗапроса;
        Выборка = Команда.Execute();
        Если Выборка.BOF = Ложь Тогда
            Выборка.MoveFirst();
			ТекТаблица = "";
			Пока Выборка.EOF = Ложь Цикл
				
				Если Выборка.Fields("table_name").value <> ТекТаблица Тогда
					СтрТаблица = ДеревоSQL.ПолучитьЭлементы().Добавить();
					СтрТаблица.ИмяТаблицыSQL = НРег(Выборка.Fields("table_name").value);
					ТекТаблица = Выборка.Fields("table_name").value;
				КонецЕсли;
				СтрИндекс = СтрТаблица.ПолучитьЭлементы().Добавить();
				СтрИндекс.Поля = НРег(Выборка.Fields("columns").value);
				СтрИндекс.ВключенныеКолонки = НРег(Выборка.Fields("included_columns").value);
				СтрИндекс.ИдИндекса =Формат(Выборка.Fields("index_id").value, "ЧГ=0");
				СтрИндекс.ИмяИндекса = НРег(Выборка.Fields("index_name").value);
				СтрИндекс.ТипИндекса = Выборка.Fields("index_type").value;
				СтрИндекс.Уникальный = Выборка.Fields("unique").value = "Unique";
				СтрИндекс.ИмяИндексаДляПоиска = НРег(СтрИндекс.ИмяИндекса);

				Выборка.MoveNext();
            КонецЦикла;
        КонецЕсли;
    Исключение
        Сообщить(ОписаниеОшибки());
		ЗакрытьСоединение(Соединение); 
		Возврат;
	КонецПопытки;

	ЗакрытьСоединение(Соединение);
КонецПроцедуры

&НаКлиенте
Процедура ЗакрытьСоединение(Соединение)

    Попытка
        Соединение.Close();
    Исключение
        Сообщить(ОписаниеОшибки());
	КонецПопытки;
	
КонецПроцедуры

&НаСервере
Процедура ТекстЗапроса()
	Обработка = РеквизитФормыВЗначение("Отчет");
	Если Режим = 0 Или Режим = 1 Тогда
		Макет = Обработка.ПолучитьМакет("Запрос_MSSQL");
	Иначе
		Макет = Обработка.ПолучитьМакет("Запрос_PG");
	КонецЕсли;	
	ТекстЗапроса = Макет.ПолучитьТекст();	
КонецПроцедуры

#КонецОбласти